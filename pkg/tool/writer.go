package tool

import (
	"bytes"
	"text/template"

	"github.com/pkg/errors"
	"github.com/spf13/afero"
)

// Writer creates a tool file to manage tool dependencies.
type Writer interface {
	Write(path string, m *Manifest) error
}

// NewWriter creates a new Writer instance.
func NewWriter(fs afero.Fs) Writer {
	return &writerImpl{
		fs: fs,
	}
}

type writerImpl struct {
	fs afero.Fs
}

func (w *writerImpl) Write(path string, m *Manifest) error {
	buf := new(bytes.Buffer)
	err := toolsGoTemplate.Execute(buf, m)
	if err != nil {
		return errors.Wrap(err, "failed to create a manifest file")
	}
	err = afero.WriteFile(w.fs, path, buf.Bytes(), 0644)
	if err != nil {
		return errors.Wrap(err, "failed to write a manifest file")
	}
	return nil
}

var (
	toolsGoTemplate = template.Must(template.New("tools.go").Funcs(template.FuncMap{
		"hasBuildMode":     hasBuildMode,
		"buildModeComment": buildModeComment,
		"needBuild":        needBuild,
		"needBuildAny":     needBuildAny,
	}).Parse(`// Code generated by github.com/izumin5210/gex. DO NOT EDIT.

// +build tools
{{- if hasBuildMode .DefaultBuildMode }}
{{ buildModeComment .DefaultBuildMode }}
{{- end }}

package tools

// tool dependencies
import (
{{- range $t := .Tools}}
{{- if hasBuildMode $t.BuildMode }}
	{{ buildModeComment $t.BuildMode }}
{{- end }}
	_ "{{$t.ImportPath}}"
{{- end}}
)
{{- if needBuildAny $ }}

// If you want to use tools, please run the following command:
//  go generate ./tools.go
//
{{- range $t := .Tools}}
{{- if needBuild $ $t }}
//go:generate go build -v -o=./bin/{{$t.Name}} {{if $.ManagerType.Vendor}}./vendor/{{end}}{{$t.ImportPath}}
{{- end}}
{{- end}}
{{- end}}
`))
)

func hasBuildMode(buildMode BuildMode) bool {
	return buildMode != BuildModeUnknown
}

func buildModeComment(buildMode BuildMode) string {
	switch buildMode {
	case BuildModeBin:
		return "//gex:bin"
	case BuildModeNoBin:
		return "//gex:nobin"
	}
	return ""
}

func needBuild(m *Manifest, t Tool) bool {
	return t.NeedBuild(m.DefaultBuildMode())
}

func needBuildAny(m *Manifest) bool {
	for _, t := range m.Tools() {
		if needBuild(m, t) {
			return true
		}
	}
	return false
}
